---
layout: post-no-feature
title: "Secrets of Solidty Part 1: Introduction and the $44k String"
category: articles
tags: [ethereum, solidity, development]
---
Welcome readers. In this series we will delve deep within the world solidity and go on a magical journey that is guaranteed to make any developer cringe and any non-developer think I’m insane. This journey will be one of discovery; we will discover not only the secrets of the language known as solidity, but also an appreciation for proper documentation. Speaking of which, I really should comment my code…

Meh, whatever. I’ll do it eventually, I’m sure Y Combinator won’t care.

My largely uncommented code aside, let us forge onwards on our noble quest to understand the secrets of solidity. Actually, before that, let me tell you why exactly we decided to code our project in solidity. As you may or may not know, there are three languages that one can use to develop in when dealing with ethereum: LLL, Serpent, and of course, Solidity. Now, LLL was completely out of the question for one very simple reason, it looked hard. Like really, really, really hard. Serpent was also pretty quickly ruled out, since I (the primary developer for the back-end) have no substantial experience in Python which is the most similar language to Serpent. So we ended up going with Solidity largely because its syntax is close enough to C and C++ (my languages of choice) that it seemed like we could learn it fairly easily. Plus, some dude named ryno55 on reddit said it was the most developed of the three, and we all know how that reddit rhinoceroses are the best judges of coding languages.

Now on to the forty-four thousand dollar string from the title that probably made all of you click on this post in the first place. Back when we first started I made a pretty simple function to get an achievement of a user. All the function did was take in the address of the user and the index number of the achievement in the array of strings, then the function simply returned a single string. This function was made so that the front end could populate a list of a user’s achievements by calling the function from within a loop. Should have worked fine, right? Wrong! Well, kinda sorta. We copied and the code into the [browser solidity](https://chriseth.github.io/browser-solidity/) to make sure everything worked fine. And it did, all of my functions did exactly what they were supposed to but we noticed something odd about the aforementioned function, it cost about 21.5 billion gas (the unit used to describe the fees for performing operations in ethereum). This was a ridiculous amount, especially given that most of the other functions only cost about 200-300 gas, and our largest function at the time cost a couple thousand gas. So we did some more investigated and came across [this](http://ether.fund/tool/calculator) ethereum cost calculator that could tell us the value of the gas in USD. Of course, we couldn’t get an exact cost because we had no way of knowing the [gas price](http://ether.fund/tool/gas-price) but we decided to try it out with the default values. And lo and behold, forty-four thousand dollars to get one goddamn string from an array. We eventually made a work around where the function returns an array of addresses that can translated into strings with another function. This whole process only costs about 5 cents despite it doing pretty much the same thing. To this day, I really have no idea why there was such a disparity in the costs of these two methods of achieving the exact same thing.

Join me next week in Part 2 of this series: The Cheeky Parameter and the Wisdom of the Stack.
Have questions or comments? Know why I almost made all of our users spend 44k on one string? Tweet me @lordskh
